// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: cfb_team_stats.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";

export const protobufPackage = "cfb";

export interface TeamStats {
  season: number;
  team: string;
  games: number;
  wins: number;
  losses: number;
  pointsPerGame: number;
  totalPoints: number;
  offenseRank: number;
  offensePlays: number;
  offenseYards: number;
  offenseYardsPerPlay: number;
  offenseTouchdowns: number;
  offenseYardsPerGame: number;
  defenseRank: number;
  defensePlays: number;
  yardsAllowed: number;
  yardsPerPlayAllowed: number;
  totalTouchdownsAllowed: number;
  pointsAllowed: number;
  avgPointsPerGameAllowed: number;
  passAttempts: number;
  passCompletions: number;
  passYards: number;
  passTouchdowns: number;
  interceptionsThrown: number;
  passYardsPerAttempt: number;
  rushAttempts: number;
  rushYards: number;
  rushTouchdowns: number;
  yardsPerRush: number;
  fumblesRecovered: number;
  interceptionsGained: number;
  turnoversLost: number;
  turnoverMargin: number;
}

export interface TeamStatsRequest {
  season?: number | undefined;
  team?: string | undefined;
}

export interface TeamStatsResponse {
  stats: TeamStats[];
}

function createBaseTeamStats(): TeamStats {
  return {
    season: 0,
    team: "",
    games: 0,
    wins: 0,
    losses: 0,
    pointsPerGame: 0,
    totalPoints: 0,
    offenseRank: 0,
    offensePlays: 0,
    offenseYards: 0,
    offenseYardsPerPlay: 0,
    offenseTouchdowns: 0,
    offenseYardsPerGame: 0,
    defenseRank: 0,
    defensePlays: 0,
    yardsAllowed: 0,
    yardsPerPlayAllowed: 0,
    totalTouchdownsAllowed: 0,
    pointsAllowed: 0,
    avgPointsPerGameAllowed: 0,
    passAttempts: 0,
    passCompletions: 0,
    passYards: 0,
    passTouchdowns: 0,
    interceptionsThrown: 0,
    passYardsPerAttempt: 0,
    rushAttempts: 0,
    rushYards: 0,
    rushTouchdowns: 0,
    yardsPerRush: 0,
    fumblesRecovered: 0,
    interceptionsGained: 0,
    turnoversLost: 0,
    turnoverMargin: 0,
  };
}

export const TeamStats: MessageFns<TeamStats> = {
  encode(message: TeamStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.season !== 0) {
      writer.uint32(8).int32(message.season);
    }
    if (message.team !== "") {
      writer.uint32(18).string(message.team);
    }
    if (message.games !== 0) {
      writer.uint32(24).int32(message.games);
    }
    if (message.wins !== 0) {
      writer.uint32(32).int32(message.wins);
    }
    if (message.losses !== 0) {
      writer.uint32(40).int32(message.losses);
    }
    if (message.pointsPerGame !== 0) {
      writer.uint32(53).float(message.pointsPerGame);
    }
    if (message.totalPoints !== 0) {
      writer.uint32(56).int32(message.totalPoints);
    }
    if (message.offenseRank !== 0) {
      writer.uint32(64).int32(message.offenseRank);
    }
    if (message.offensePlays !== 0) {
      writer.uint32(72).int32(message.offensePlays);
    }
    if (message.offenseYards !== 0) {
      writer.uint32(80).int32(message.offenseYards);
    }
    if (message.offenseYardsPerPlay !== 0) {
      writer.uint32(93).float(message.offenseYardsPerPlay);
    }
    if (message.offenseTouchdowns !== 0) {
      writer.uint32(96).int32(message.offenseTouchdowns);
    }
    if (message.offenseYardsPerGame !== 0) {
      writer.uint32(109).float(message.offenseYardsPerGame);
    }
    if (message.defenseRank !== 0) {
      writer.uint32(112).int32(message.defenseRank);
    }
    if (message.defensePlays !== 0) {
      writer.uint32(120).int32(message.defensePlays);
    }
    if (message.yardsAllowed !== 0) {
      writer.uint32(128).int32(message.yardsAllowed);
    }
    if (message.yardsPerPlayAllowed !== 0) {
      writer.uint32(141).float(message.yardsPerPlayAllowed);
    }
    if (message.totalTouchdownsAllowed !== 0) {
      writer.uint32(144).int32(message.totalTouchdownsAllowed);
    }
    if (message.pointsAllowed !== 0) {
      writer.uint32(152).int32(message.pointsAllowed);
    }
    if (message.avgPointsPerGameAllowed !== 0) {
      writer.uint32(165).float(message.avgPointsPerGameAllowed);
    }
    if (message.passAttempts !== 0) {
      writer.uint32(168).int32(message.passAttempts);
    }
    if (message.passCompletions !== 0) {
      writer.uint32(176).int32(message.passCompletions);
    }
    if (message.passYards !== 0) {
      writer.uint32(184).int32(message.passYards);
    }
    if (message.passTouchdowns !== 0) {
      writer.uint32(192).int32(message.passTouchdowns);
    }
    if (message.interceptionsThrown !== 0) {
      writer.uint32(200).int32(message.interceptionsThrown);
    }
    if (message.passYardsPerAttempt !== 0) {
      writer.uint32(213).float(message.passYardsPerAttempt);
    }
    if (message.rushAttempts !== 0) {
      writer.uint32(216).int32(message.rushAttempts);
    }
    if (message.rushYards !== 0) {
      writer.uint32(224).int32(message.rushYards);
    }
    if (message.rushTouchdowns !== 0) {
      writer.uint32(232).int32(message.rushTouchdowns);
    }
    if (message.yardsPerRush !== 0) {
      writer.uint32(245).float(message.yardsPerRush);
    }
    if (message.fumblesRecovered !== 0) {
      writer.uint32(248).int32(message.fumblesRecovered);
    }
    if (message.interceptionsGained !== 0) {
      writer.uint32(256).int32(message.interceptionsGained);
    }
    if (message.turnoversLost !== 0) {
      writer.uint32(264).int32(message.turnoversLost);
    }
    if (message.turnoverMargin !== 0) {
      writer.uint32(272).int32(message.turnoverMargin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.season = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.team = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.games = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.wins = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.losses = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.pointsPerGame = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalPoints = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.offenseRank = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.offensePlays = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.offenseYards = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 93) {
            break;
          }

          message.offenseYardsPerPlay = reader.float();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.offenseTouchdowns = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.offenseYardsPerGame = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.defenseRank = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.defensePlays = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.yardsAllowed = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 141) {
            break;
          }

          message.yardsPerPlayAllowed = reader.float();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.totalTouchdownsAllowed = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.pointsAllowed = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 165) {
            break;
          }

          message.avgPointsPerGameAllowed = reader.float();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.passAttempts = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.passCompletions = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.passYards = reader.int32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.passTouchdowns = reader.int32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.interceptionsThrown = reader.int32();
          continue;
        }
        case 26: {
          if (tag !== 213) {
            break;
          }

          message.passYardsPerAttempt = reader.float();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.rushAttempts = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.rushYards = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.rushTouchdowns = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 245) {
            break;
          }

          message.yardsPerRush = reader.float();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.fumblesRecovered = reader.int32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.interceptionsGained = reader.int32();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.turnoversLost = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.turnoverMargin = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamStats {
    return {
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
      team: isSet(object.team) ? globalThis.String(object.team) : "",
      games: isSet(object.games) ? globalThis.Number(object.games) : 0,
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
      pointsPerGame: isSet(object.pointsPerGame) ? globalThis.Number(object.pointsPerGame) : 0,
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      offenseRank: isSet(object.offenseRank) ? globalThis.Number(object.offenseRank) : 0,
      offensePlays: isSet(object.offensePlays) ? globalThis.Number(object.offensePlays) : 0,
      offenseYards: isSet(object.offenseYards) ? globalThis.Number(object.offenseYards) : 0,
      offenseYardsPerPlay: isSet(object.offenseYardsPerPlay) ? globalThis.Number(object.offenseYardsPerPlay) : 0,
      offenseTouchdowns: isSet(object.offenseTouchdowns) ? globalThis.Number(object.offenseTouchdowns) : 0,
      offenseYardsPerGame: isSet(object.offenseYardsPerGame) ? globalThis.Number(object.offenseYardsPerGame) : 0,
      defenseRank: isSet(object.defenseRank) ? globalThis.Number(object.defenseRank) : 0,
      defensePlays: isSet(object.defensePlays) ? globalThis.Number(object.defensePlays) : 0,
      yardsAllowed: isSet(object.yardsAllowed) ? globalThis.Number(object.yardsAllowed) : 0,
      yardsPerPlayAllowed: isSet(object.yardsPerPlayAllowed) ? globalThis.Number(object.yardsPerPlayAllowed) : 0,
      totalTouchdownsAllowed: isSet(object.totalTouchdownsAllowed)
        ? globalThis.Number(object.totalTouchdownsAllowed)
        : 0,
      pointsAllowed: isSet(object.pointsAllowed) ? globalThis.Number(object.pointsAllowed) : 0,
      avgPointsPerGameAllowed: isSet(object.avgPointsPerGameAllowed)
        ? globalThis.Number(object.avgPointsPerGameAllowed)
        : 0,
      passAttempts: isSet(object.passAttempts) ? globalThis.Number(object.passAttempts) : 0,
      passCompletions: isSet(object.passCompletions) ? globalThis.Number(object.passCompletions) : 0,
      passYards: isSet(object.passYards) ? globalThis.Number(object.passYards) : 0,
      passTouchdowns: isSet(object.passTouchdowns) ? globalThis.Number(object.passTouchdowns) : 0,
      interceptionsThrown: isSet(object.interceptionsThrown) ? globalThis.Number(object.interceptionsThrown) : 0,
      passYardsPerAttempt: isSet(object.passYardsPerAttempt) ? globalThis.Number(object.passYardsPerAttempt) : 0,
      rushAttempts: isSet(object.rushAttempts) ? globalThis.Number(object.rushAttempts) : 0,
      rushYards: isSet(object.rushYards) ? globalThis.Number(object.rushYards) : 0,
      rushTouchdowns: isSet(object.rushTouchdowns) ? globalThis.Number(object.rushTouchdowns) : 0,
      yardsPerRush: isSet(object.yardsPerRush) ? globalThis.Number(object.yardsPerRush) : 0,
      fumblesRecovered: isSet(object.fumblesRecovered) ? globalThis.Number(object.fumblesRecovered) : 0,
      interceptionsGained: isSet(object.interceptionsGained) ? globalThis.Number(object.interceptionsGained) : 0,
      turnoversLost: isSet(object.turnoversLost) ? globalThis.Number(object.turnoversLost) : 0,
      turnoverMargin: isSet(object.turnoverMargin) ? globalThis.Number(object.turnoverMargin) : 0,
    };
  },

  toJSON(message: TeamStats): unknown {
    const obj: any = {};
    if (message.season !== 0) {
      obj.season = Math.round(message.season);
    }
    if (message.team !== "") {
      obj.team = message.team;
    }
    if (message.games !== 0) {
      obj.games = Math.round(message.games);
    }
    if (message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    if (message.pointsPerGame !== 0) {
      obj.pointsPerGame = message.pointsPerGame;
    }
    if (message.totalPoints !== 0) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.offenseRank !== 0) {
      obj.offenseRank = Math.round(message.offenseRank);
    }
    if (message.offensePlays !== 0) {
      obj.offensePlays = Math.round(message.offensePlays);
    }
    if (message.offenseYards !== 0) {
      obj.offenseYards = Math.round(message.offenseYards);
    }
    if (message.offenseYardsPerPlay !== 0) {
      obj.offenseYardsPerPlay = message.offenseYardsPerPlay;
    }
    if (message.offenseTouchdowns !== 0) {
      obj.offenseTouchdowns = Math.round(message.offenseTouchdowns);
    }
    if (message.offenseYardsPerGame !== 0) {
      obj.offenseYardsPerGame = message.offenseYardsPerGame;
    }
    if (message.defenseRank !== 0) {
      obj.defenseRank = Math.round(message.defenseRank);
    }
    if (message.defensePlays !== 0) {
      obj.defensePlays = Math.round(message.defensePlays);
    }
    if (message.yardsAllowed !== 0) {
      obj.yardsAllowed = Math.round(message.yardsAllowed);
    }
    if (message.yardsPerPlayAllowed !== 0) {
      obj.yardsPerPlayAllowed = message.yardsPerPlayAllowed;
    }
    if (message.totalTouchdownsAllowed !== 0) {
      obj.totalTouchdownsAllowed = Math.round(message.totalTouchdownsAllowed);
    }
    if (message.pointsAllowed !== 0) {
      obj.pointsAllowed = Math.round(message.pointsAllowed);
    }
    if (message.avgPointsPerGameAllowed !== 0) {
      obj.avgPointsPerGameAllowed = message.avgPointsPerGameAllowed;
    }
    if (message.passAttempts !== 0) {
      obj.passAttempts = Math.round(message.passAttempts);
    }
    if (message.passCompletions !== 0) {
      obj.passCompletions = Math.round(message.passCompletions);
    }
    if (message.passYards !== 0) {
      obj.passYards = Math.round(message.passYards);
    }
    if (message.passTouchdowns !== 0) {
      obj.passTouchdowns = Math.round(message.passTouchdowns);
    }
    if (message.interceptionsThrown !== 0) {
      obj.interceptionsThrown = Math.round(message.interceptionsThrown);
    }
    if (message.passYardsPerAttempt !== 0) {
      obj.passYardsPerAttempt = message.passYardsPerAttempt;
    }
    if (message.rushAttempts !== 0) {
      obj.rushAttempts = Math.round(message.rushAttempts);
    }
    if (message.rushYards !== 0) {
      obj.rushYards = Math.round(message.rushYards);
    }
    if (message.rushTouchdowns !== 0) {
      obj.rushTouchdowns = Math.round(message.rushTouchdowns);
    }
    if (message.yardsPerRush !== 0) {
      obj.yardsPerRush = message.yardsPerRush;
    }
    if (message.fumblesRecovered !== 0) {
      obj.fumblesRecovered = Math.round(message.fumblesRecovered);
    }
    if (message.interceptionsGained !== 0) {
      obj.interceptionsGained = Math.round(message.interceptionsGained);
    }
    if (message.turnoversLost !== 0) {
      obj.turnoversLost = Math.round(message.turnoversLost);
    }
    if (message.turnoverMargin !== 0) {
      obj.turnoverMargin = Math.round(message.turnoverMargin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeamStats>, I>>(base?: I): TeamStats {
    return TeamStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeamStats>, I>>(object: I): TeamStats {
    const message = createBaseTeamStats();
    message.season = object.season ?? 0;
    message.team = object.team ?? "";
    message.games = object.games ?? 0;
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    message.pointsPerGame = object.pointsPerGame ?? 0;
    message.totalPoints = object.totalPoints ?? 0;
    message.offenseRank = object.offenseRank ?? 0;
    message.offensePlays = object.offensePlays ?? 0;
    message.offenseYards = object.offenseYards ?? 0;
    message.offenseYardsPerPlay = object.offenseYardsPerPlay ?? 0;
    message.offenseTouchdowns = object.offenseTouchdowns ?? 0;
    message.offenseYardsPerGame = object.offenseYardsPerGame ?? 0;
    message.defenseRank = object.defenseRank ?? 0;
    message.defensePlays = object.defensePlays ?? 0;
    message.yardsAllowed = object.yardsAllowed ?? 0;
    message.yardsPerPlayAllowed = object.yardsPerPlayAllowed ?? 0;
    message.totalTouchdownsAllowed = object.totalTouchdownsAllowed ?? 0;
    message.pointsAllowed = object.pointsAllowed ?? 0;
    message.avgPointsPerGameAllowed = object.avgPointsPerGameAllowed ?? 0;
    message.passAttempts = object.passAttempts ?? 0;
    message.passCompletions = object.passCompletions ?? 0;
    message.passYards = object.passYards ?? 0;
    message.passTouchdowns = object.passTouchdowns ?? 0;
    message.interceptionsThrown = object.interceptionsThrown ?? 0;
    message.passYardsPerAttempt = object.passYardsPerAttempt ?? 0;
    message.rushAttempts = object.rushAttempts ?? 0;
    message.rushYards = object.rushYards ?? 0;
    message.rushTouchdowns = object.rushTouchdowns ?? 0;
    message.yardsPerRush = object.yardsPerRush ?? 0;
    message.fumblesRecovered = object.fumblesRecovered ?? 0;
    message.interceptionsGained = object.interceptionsGained ?? 0;
    message.turnoversLost = object.turnoversLost ?? 0;
    message.turnoverMargin = object.turnoverMargin ?? 0;
    return message;
  },
};

function createBaseTeamStatsRequest(): TeamStatsRequest {
  return { season: undefined, team: undefined };
}

export const TeamStatsRequest: MessageFns<TeamStatsRequest> = {
  encode(message: TeamStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.season !== undefined) {
      writer.uint32(8).int32(message.season);
    }
    if (message.team !== undefined) {
      writer.uint32(18).string(message.team);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.season = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.team = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamStatsRequest {
    return {
      season: isSet(object.season) ? globalThis.Number(object.season) : undefined,
      team: isSet(object.team) ? globalThis.String(object.team) : undefined,
    };
  },

  toJSON(message: TeamStatsRequest): unknown {
    const obj: any = {};
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    if (message.team !== undefined) {
      obj.team = message.team;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeamStatsRequest>, I>>(base?: I): TeamStatsRequest {
    return TeamStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeamStatsRequest>, I>>(object: I): TeamStatsRequest {
    const message = createBaseTeamStatsRequest();
    message.season = object.season ?? undefined;
    message.team = object.team ?? undefined;
    return message;
  },
};

function createBaseTeamStatsResponse(): TeamStatsResponse {
  return { stats: [] };
}

export const TeamStatsResponse: MessageFns<TeamStatsResponse> = {
  encode(message: TeamStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stats) {
      TeamStats.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stats.push(TeamStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamStatsResponse {
    return {
      stats: globalThis.Array.isArray(object?.stats) ? object.stats.map((e: any) => TeamStats.fromJSON(e)) : [],
    };
  },

  toJSON(message: TeamStatsResponse): unknown {
    const obj: any = {};
    if (message.stats?.length) {
      obj.stats = message.stats.map((e) => TeamStats.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeamStatsResponse>, I>>(base?: I): TeamStatsResponse {
    return TeamStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeamStatsResponse>, I>>(object: I): TeamStatsResponse {
    const message = createBaseTeamStatsResponse();
    message.stats = object.stats?.map((e) => TeamStats.fromPartial(e)) || [];
    return message;
  },
};

export interface Stats {
  GetTeamStats(request: DeepPartial<TeamStatsRequest>, metadata?: grpc.Metadata): Promise<TeamStatsResponse>;
}

export class StatsClientImpl implements Stats {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetTeamStats = this.GetTeamStats.bind(this);
  }

  GetTeamStats(request: DeepPartial<TeamStatsRequest>, metadata?: grpc.Metadata): Promise<TeamStatsResponse> {
    return this.rpc.unary(StatsGetTeamStatsDesc, TeamStatsRequest.fromPartial(request), metadata);
  }
}

export const StatsDesc = { serviceName: "cfb.Stats" };

export const StatsGetTeamStatsDesc: UnaryMethodDefinitionish = {
  methodName: "GetTeamStats",
  service: StatsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TeamStatsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TeamStatsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
